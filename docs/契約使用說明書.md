# API 契約使用說明書

> **版本**: v1.0.0
> **最後更新**: 2025-12-29
> **適用專案**: 線上課程平台 MVP
> **維護者**: 冠瑋 (Tech Lead)

---

## 目錄

1. [契約文件總覽](#1-契約文件總覽)
2. [前端使用指南](#2-前端使用指南)
3. [後端使用指南](#3-後端使用指南)
4. [Mock Server 設定](#4-mock-server-設定)
5. [自動化生成型別檔案](#5-自動化生成型別檔案)
6. [CI/CD 整合](#6-cicd-整合)
7. [協作流程與規範](#7-協作流程與規範)
8. [常見問題 FAQ](#8-常見問題-faq)

---

## 1. 契約文件總覽

### 1.1 文件清單

```
D:\sideproject\CONTRACT_TEMPLATES\
├── course_platform_api_contract.yaml  # OpenAPI 3.0 契約 (單一事實來源)
├── course_platform_types.ts           # 前端 TypeScript 介面
└── course_platform_schemas.py         # 後端 Python Pydantic 模型
```

### 1.2 文件角色

| 文件 | 用途 | 使用者 | 使用場景 |
|------|------|--------|----------|
| `api_contract.yaml` | 單一事實來源 (SSOT) | 全團隊 | Review、Mock Server、測試、文件生成 |
| `types.ts` | 前端型別定義 | 古古、Jane | React/Next.js 開發 |
| `schemas.py` | 後端資料模型 | 冠瑋、Celia、子科 | FastAPI/Flask 開發 |

### 1.3 API 模組與負責人

| 模組 | 端點數 | 後端 Owner | 前端 Owner | WBS 任務 |
|------|--------|------------|------------|----------|
| Auth | 4 | Celia | 古古 & Jane | 2.1.B, 2.2.B |
| Users | 2 | Celia | 古古 & Jane | - |
| Courses | 5 | 子科 | 古古 & Jane | 3.1.B |
| Videos | 6 | 冠瑋 | 古古 & Jane | 4.1.B, 4.2.B |
| Playback | 3 | Celia | 古古 & Jane | 5.1.B |
| Enrollments | 3 | 子科 | 古古 & Jane | - |

---

## 2. 前端使用指南

### 2.1 安裝型別檔案

```bash
# 方法 1: 直接複製到專案
cp D:\sideproject\CONTRACT_TEMPLATES\course_platform_types.ts src/types/api.ts

# 方法 2: 使用符號連結 (推薦，保持同步)
# Windows PowerShell (以管理員身份執行)
New-Item -ItemType SymbolicLink -Path "src\types\api.ts" -Target "D:\sideproject\CONTRACT_TEMPLATES\course_platform_types.ts"

# Linux/Mac
ln -s D:/sideproject/CONTRACT_TEMPLATES/course_platform_types.ts src/types/api.ts
```

### 2.2 建立 API 客戶端

在 `src/services/api.ts` 建立：

```typescript
import axios, { AxiosError } from 'axios';
import type {
  // Auth
  AuthResponse,
  GoogleAuthRequest,
  RefreshTokenRequest,
  UserResponse,
  // Courses
  CourseListResponse,
  CourseDetailResponse,
  CourseResponse,
  GetCoursesParams,
  CreateCourseRequest,
  // Videos
  VideoUploadResponse,
  VideoStatusResponse,
  CreateVideoRequest,
  // Playback
  PlaybackResponse,
  ProgressResponse,
  UpdateProgressRequest,
  // Enrollments
  EnrollmentListResponse,
  EnrollmentResponse,
  // Utils
  ErrorResponse,
  API_PATHS,
  isErrorResponse,
} from '@/types/api';

// ============================================================
// API 客戶端設定
// ============================================================

const api = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000/api/v1',
  headers: { 'Content-Type': 'application/json' },
  timeout: 30000,
});

// Token 管理
const tokenManager = {
  getAccessToken: () => localStorage.getItem('accessToken'),
  getRefreshToken: () => localStorage.getItem('refreshToken'),
  setTokens: (access: string, refresh: string) => {
    localStorage.setItem('accessToken', access);
    localStorage.setItem('refreshToken', refresh);
  },
  clearTokens: () => {
    localStorage.removeItem('accessToken');
    localStorage.removeItem('refreshToken');
  },
};

// 請求攔截器: 自動附加 Token
api.interceptors.request.use((config) => {
  const token = tokenManager.getAccessToken();
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// 回應攔截器: 自動刷新 Token
api.interceptors.response.use(
  (response) => response,
  async (error: AxiosError<ErrorResponse>) => {
    const originalRequest = error.config;

    if (error.response?.status === 401 && originalRequest) {
      try {
        const refreshToken = tokenManager.getRefreshToken();
        if (refreshToken) {
          const { data } = await axios.post<AuthResponse>(
            `${api.defaults.baseURL}${API_PATHS.AUTH_REFRESH}`,
            { refreshToken }
          );

          if (data.success) {
            tokenManager.setTokens(data.data.accessToken, data.data.refreshToken);
            originalRequest.headers.Authorization = `Bearer ${data.data.accessToken}`;
            return api(originalRequest);
          }
        }
      } catch {
        tokenManager.clearTokens();
        window.location.href = '/login';
      }
    }

    return Promise.reject(error);
  }
);

// ============================================================
// Auth API
// ============================================================

export const authApi = {
  /** Google OAuth2 登入 */
  googleLogin: async (idToken: string): Promise<AuthResponse> => {
    const { data } = await api.post<AuthResponse>(API_PATHS.AUTH_GOOGLE, {
      idToken,
    } as GoogleAuthRequest);

    if (data.success) {
      tokenManager.setTokens(data.data.accessToken, data.data.refreshToken);
    }
    return data;
  },

  /** 登出 */
  logout: async (): Promise<void> => {
    await api.post(API_PATHS.AUTH_LOGOUT);
    tokenManager.clearTokens();
  },

  /** 取得當前用戶 */
  getMe: async (): Promise<UserResponse> => {
    const { data } = await api.get<UserResponse>(API_PATHS.AUTH_ME);
    return data;
  },
};

// ============================================================
// Courses API
// ============================================================

export const coursesApi = {
  /** 取得課程列表 */
  getCourses: async (params?: GetCoursesParams): Promise<CourseListResponse> => {
    const { data } = await api.get<CourseListResponse>(API_PATHS.COURSES, { params });
    return data;
  },

  /** 取得課程詳情 */
  getCourse: async (courseId: string): Promise<CourseDetailResponse> => {
    const { data } = await api.get<CourseDetailResponse>(API_PATHS.COURSE(courseId));
    return data;
  },

  /** 建立課程 (講師) */
  createCourse: async (request: CreateCourseRequest): Promise<CourseResponse> => {
    const { data } = await api.post<CourseResponse>(API_PATHS.COURSES, request);
    return data;
  },
};

// ============================================================
// Videos API
// ============================================================

export const videosApi = {
  /** 建立影片 (取得上傳 URL) */
  createVideo: async (
    courseId: string,
    request: CreateVideoRequest
  ): Promise<VideoUploadResponse> => {
    const { data } = await api.post<VideoUploadResponse>(
      API_PATHS.COURSE_VIDEOS(courseId),
      request
    );
    return data;
  },

  /** 通知上傳完成 */
  completeUpload: async (videoId: string, uploadId: string): Promise<void> => {
    await api.post(API_PATHS.VIDEO_UPLOAD_COMPLETE(videoId), { uploadId });
  },

  /** 查詢影片狀態 */
  getVideoStatus: async (videoId: string): Promise<VideoStatusResponse> => {
    const { data } = await api.get<VideoStatusResponse>(API_PATHS.VIDEO_STATUS(videoId));
    return data;
  },
};

// ============================================================
// Playback API
// ============================================================

export const playbackApi = {
  /** 取得播放資訊 */
  getPlayback: async (videoId: string): Promise<PlaybackResponse> => {
    const { data } = await api.get<PlaybackResponse>(API_PATHS.VIDEO_PLAYBACK(videoId));
    return data;
  },

  /** 取得播放進度 */
  getProgress: async (videoId: string): Promise<ProgressResponse> => {
    const { data } = await api.get<ProgressResponse>(API_PATHS.VIDEO_PROGRESS(videoId));
    return data;
  },

  /** 更新播放進度 */
  updateProgress: async (
    videoId: string,
    request: UpdateProgressRequest
  ): Promise<ProgressResponse> => {
    const { data } = await api.put<ProgressResponse>(
      API_PATHS.VIDEO_PROGRESS(videoId),
      request
    );
    return data;
  },
};

// ============================================================
// Enrollments API
// ============================================================

export const enrollmentsApi = {
  /** 取得我的課程 */
  getMyEnrollments: async (): Promise<EnrollmentListResponse> => {
    const { data } = await api.get<EnrollmentListResponse>(API_PATHS.ENROLLMENTS);
    return data;
  },

  /** 報名課程 */
  enroll: async (courseId: string): Promise<EnrollmentResponse> => {
    const { data } = await api.post<EnrollmentResponse>(API_PATHS.ENROLLMENTS, {
      courseId,
    });
    return data;
  },

  /** 查詢報名狀態 */
  getEnrollmentStatus: async (courseId: string): Promise<EnrollmentResponse> => {
    const { data } = await api.get<EnrollmentResponse>(API_PATHS.ENROLLMENT(courseId));
    return data;
  },
};

// 統一導出
export default {
  auth: authApi,
  courses: coursesApi,
  videos: videosApi,
  playback: playbackApi,
  enrollments: enrollmentsApi,
};
```

### 2.3 React 組件範例

#### 課程列表頁面

```tsx
// src/app/courses/page.tsx
'use client';

import { useEffect, useState } from 'react';
import { coursesApi } from '@/services/api';
import type { CourseWithInstructor, GetCoursesParams } from '@/types/api';

export default function CoursesPage() {
  const [courses, setCourses] = useState<CourseWithInstructor[]>([]);
  const [loading, setLoading] = useState(true);
  const [search, setSearch] = useState('');
  const [page, setPage] = useState(1);
  const [totalPages, setTotalPages] = useState(1);

  const fetchCourses = async (params: GetCoursesParams) => {
    setLoading(true);
    try {
      const response = await coursesApi.getCourses(params);
      if (response.success) {
        setCourses(response.data.courses);
        setTotalPages(response.data.pagination.totalPages);
      }
    } catch (error) {
      console.error('Failed to fetch courses:', error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchCourses({ page, limit: 12, search: search || undefined });
  }, [page, search]);

  const handleSearch = (e: React.FormEvent) => {
    e.preventDefault();
    setPage(1);
    fetchCourses({ page: 1, limit: 12, search: search || undefined });
  };

  if (loading) return <div>載入中...</div>;

  return (
    <div className="container mx-auto p-4">
      {/* 搜尋欄 */}
      <form onSubmit={handleSearch} className="mb-6">
        <input
          type="text"
          value={search}
          onChange={(e) => setSearch(e.target.value)}
          placeholder="搜尋課程..."
          className="border rounded px-4 py-2 w-64"
        />
        <button type="submit" className="ml-2 bg-blue-500 text-white px-4 py-2 rounded">
          搜尋
        </button>
      </form>

      {/* 課程列表 */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        {courses.map((course) => (
          <div key={course.id} className="border rounded-lg overflow-hidden shadow">
            <img
              src={course.thumbnail || '/placeholder.jpg'}
              alt={course.title}
              className="w-full h-48 object-cover"
            />
            <div className="p-4">
              <h3 className="font-bold text-lg">{course.title}</h3>
              <p className="text-gray-600 text-sm mt-1">
                {course.description?.slice(0, 100)}...
              </p>
              <div className="flex items-center mt-3">
                <img
                  src={course.instructor.avatar || '/avatar.jpg'}
                  alt={course.instructor.name}
                  className="w-8 h-8 rounded-full"
                />
                <span className="ml-2 text-sm">{course.instructor.name}</span>
              </div>
              <div className="mt-3 text-sm text-gray-500">
                {course.videoCount} 部影片 | {course.enrollmentCount} 人報名
              </div>
            </div>
          </div>
        ))}
      </div>

      {/* 分頁 */}
      <div className="flex justify-center mt-8 gap-2">
        <button
          onClick={() => setPage((p) => Math.max(1, p - 1))}
          disabled={page === 1}
          className="px-4 py-2 border rounded disabled:opacity-50"
        >
          上一頁
        </button>
        <span className="px-4 py-2">
          {page} / {totalPages}
        </span>
        <button
          onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
          disabled={page === totalPages}
          className="px-4 py-2 border rounded disabled:opacity-50"
        >
          下一頁
        </button>
      </div>
    </div>
  );
}
```

#### HLS 播放器組件

```tsx
// src/components/VideoPlayer.tsx
'use client';

import { useEffect, useRef, useState } from 'react';
import Hls from 'hls.js';
import { playbackApi } from '@/services/api';
import type { PlaybackResponse } from '@/types/api';

interface VideoPlayerProps {
  videoId: string;
}

export default function VideoPlayer({ videoId }: VideoPlayerProps) {
  const videoRef = useRef<HTMLVideoElement>(null);
  const hlsRef = useRef<Hls | null>(null);
  const [playbackData, setPlaybackData] = useState<PlaybackResponse['data'] | null>(null);
  const [error, setError] = useState<string | null>(null);

  // 載入播放資訊
  useEffect(() => {
    const loadPlayback = async () => {
      try {
        const response = await playbackApi.getPlayback(videoId);
        if (response.success) {
          setPlaybackData(response.data);
        }
      } catch (err: any) {
        setError(err.response?.data?.error?.message || '無法載入影片');
      }
    };
    loadPlayback();
  }, [videoId]);

  // 初始化 HLS 播放器
  useEffect(() => {
    if (!playbackData || !videoRef.current) return;

    const video = videoRef.current;

    if (Hls.isSupported()) {
      const hls = new Hls({
        startPosition: playbackData.progress?.position || 0,
      });
      hls.loadSource(playbackData.hlsUrl);
      hls.attachMedia(video);
      hlsRef.current = hls;

      hls.on(Hls.Events.ERROR, (_, data) => {
        if (data.fatal) {
          setError('播放發生錯誤');
        }
      });
    } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
      // Safari 原生支援
      video.src = playbackData.hlsUrl;
      if (playbackData.progress?.position) {
        video.currentTime = playbackData.progress.position;
      }
    }

    return () => {
      hlsRef.current?.destroy();
    };
  }, [playbackData]);

  // 定期回報播放進度 (每 10 秒)
  useEffect(() => {
    if (!videoRef.current || !playbackData) return;

    const video = videoRef.current;
    let lastReportTime = 0;

    const handleTimeUpdate = () => {
      const currentTime = Math.floor(video.currentTime);
      if (currentTime - lastReportTime >= 10) {
        lastReportTime = currentTime;
        playbackApi.updateProgress(videoId, {
          position: currentTime,
          duration: Math.floor(video.duration),
        });
      }
    };

    video.addEventListener('timeupdate', handleTimeUpdate);
    return () => video.removeEventListener('timeupdate', handleTimeUpdate);
  }, [videoId, playbackData]);

  if (error) {
    return <div className="bg-red-100 text-red-700 p-4 rounded">{error}</div>;
  }

  if (!playbackData) {
    return <div className="animate-pulse bg-gray-200 h-64 rounded" />;
  }

  return (
    <div className="relative">
      <video
        ref={videoRef}
        controls
        className="w-full rounded-lg"
        poster={playbackData.title}
      />
      <h2 className="mt-4 text-xl font-bold">{playbackData.title}</h2>
    </div>
  );
}
```

---

## 3. 後端使用指南

### 3.1 安裝 Schema 檔案

```bash
# 複製到專案
cp D:\sideproject\CONTRACT_TEMPLATES\course_platform_schemas.py app/schemas/

# 安裝依賴
pip install pydantic[email]
```

### 3.2 FastAPI 路由範例

#### 課程 API (子科負責)

```python
# app/routers/courses.py
from fastapi import APIRouter, Depends, HTTPException, Query
from typing import Optional
from sqlalchemy.orm import Session

from app.database import get_db
from app.schemas.course_platform_schemas import (
    CourseListResponse,
    CourseDetailResponse,
    CourseResponse,
    CourseListData,
    GetCoursesParams,
    CreateCourseRequest,
    UpdateCourseRequest,
    Pagination,
    create_error_response,
    APIErrorCode,
)
from app.services.course_service import CourseService
from app.dependencies import get_current_user, get_current_instructor

router = APIRouter(prefix="/courses", tags=["Courses"])


@router.get("", response_model=CourseListResponse)
async def get_courses(
    page: int = Query(1, ge=1),
    limit: int = Query(12, ge=1, le=50),
    search: Optional[str] = Query(None, max_length=100),
    category: Optional[str] = None,
    sortBy: str = Query("createdAt"),
    sortOrder: str = Query("desc"),
    db: Session = Depends(get_db),
):
    """
    取得課程列表

    - **WBS 任務**: 3.1.B
    - **Owner**: 子科
    - **前端對接**: 古古 & Jane (3.2.F)
    """
    service = CourseService(db)
    params = GetCoursesParams(
        page=page,
        limit=limit,
        search=search,
        category=category,
        sortBy=sortBy,
        sortOrder=sortOrder,
    )

    courses, total = service.get_courses(params)

    return CourseListResponse(
        success=True,
        data=CourseListData(
            courses=courses,
            pagination=Pagination(
                page=page,
                limit=limit,
                total=total,
                totalPages=(total + limit - 1) // limit,
            ),
        ),
    )


@router.get("/{course_id}", response_model=CourseDetailResponse)
async def get_course(
    course_id: str,
    db: Session = Depends(get_db),
):
    """
    取得課程詳情

    - **WBS 任務**: 3.1.B
    - **Owner**: 子科
    - **回傳**: 課程資訊、講師、章節、影片列表
    """
    service = CourseService(db)
    course = service.get_course_detail(course_id)

    if not course:
        raise HTTPException(status_code=404, detail={
            "success": False,
            "error": {
                "code": APIErrorCode.NOT_FOUND.value,
                "message": "找不到指定的課程",
            }
        })

    return CourseDetailResponse(success=True, data=course)


@router.post("", response_model=CourseResponse, status_code=201)
async def create_course(
    request: CreateCourseRequest,
    current_user = Depends(get_current_instructor),
    db: Session = Depends(get_db),
):
    """
    建立新課程 (講師專用)

    - **權限**: instructor, admin
    """
    service = CourseService(db)
    course = service.create_course(request, current_user.id)
    return CourseResponse(success=True, data=course)
```

#### 影片上傳 API (冠瑋負責)

```python
# app/routers/videos.py
from fastapi import APIRouter, Depends, HTTPException
from datetime import datetime, timedelta

from app.schemas.course_platform_schemas import (
    CreateVideoRequest,
    VideoUploadResponse,
    VideoUploadData,
    VideoStatusResponse,
    VideoStatusData,
    UploadInfo,
    VideoStatus,
    ResolutionStatus,
    ResolutionProgressInfo,
    generate_video_id,
    generate_upload_id,
    create_error_response,
    APIErrorCode,
)
from app.services.gcs_service import GCSService
from app.services.video_service import VideoService
from app.dependencies import get_current_instructor

router = APIRouter(tags=["Videos"])


@router.post(
    "/courses/{course_id}/videos",
    response_model=VideoUploadResponse,
    status_code=201
)
async def create_video(
    course_id: str,
    request: CreateVideoRequest,
    current_user = Depends(get_current_instructor),
    gcs_service: GCSService = Depends(),
    video_service: VideoService = Depends(),
):
    """
    建立影片記錄並取得上傳 URL

    - **WBS 任務**: 4.1.B GCS Signed URL 上傳機制
    - **Owner**: 冠瑋

    流程:
    1. 建立影片記錄
    2. 生成 GCS Signed URL
    3. 前端使用 URL 直接上傳至 GCS
    """
    # 驗證課程擁有者
    if not video_service.verify_course_owner(course_id, current_user.id):
        raise HTTPException(status_code=403, detail={
            "success": False,
            "error": {
                "code": APIErrorCode.FORBIDDEN.value,
                "message": "您沒有權限在此課程新增影片",
            }
        })

    video_id = generate_video_id()
    upload_id = generate_upload_id()

    # 建立影片記錄
    video_service.create_video(
        video_id=video_id,
        course_id=course_id,
        title=request.title,
        section_id=request.sectionId,
        original_filename=request.filename,
        file_size=request.fileSize,
    )

    # 生成 GCS Signed URL
    signed_url = gcs_service.generate_resumable_upload_url(
        video_id=video_id,
        content_type=request.mimeType.value,
    )

    # 計算分段數
    chunk_size = 5 * 1024 * 1024  # 5MB
    total_chunks = (request.fileSize + chunk_size - 1) // chunk_size

    return VideoUploadResponse(
        success=True,
        data=VideoUploadData(
            id=video_id,
            title=request.title,
            status=VideoStatus.PENDING_UPLOAD,
            upload=UploadInfo(
                uploadId=upload_id,
                signedUrl=signed_url,
                expiresAt=datetime.utcnow() + timedelta(hours=1),
                chunkSize=chunk_size,
                totalChunks=total_chunks,
            ),
        ),
    )


@router.get("/videos/{video_id}/status", response_model=VideoStatusResponse)
async def get_video_status(
    video_id: str,
    video_service: VideoService = Depends(),
):
    """
    查詢影片處理狀態

    - **WBS 任務**: 4.2.B 雲端轉碼 Pipeline
    - **Owner**: 冠瑋
    - **用途**: 前端輪詢轉碼進度
    """
    status = video_service.get_video_status(video_id)

    if not status:
        raise HTTPException(status_code=404)

    return VideoStatusResponse(
        success=True,
        data=VideoStatusData(
            id=video_id,
            status=status.status,
            progress=status.progress,
            resolutions=[
                ResolutionProgressInfo(
                    resolution="720p",
                    status=status.resolution_720p,
                ),
                ResolutionProgressInfo(
                    resolution="1080p",
                    status=status.resolution_1080p,
                ),
            ],
            estimatedCompletion=status.estimated_completion,
            errorMessage=status.error_message,
        ),
    )
```

#### 播放 API (Celia 負責)

```python
# app/routers/playback.py
from fastapi import APIRouter, Depends, HTTPException
from datetime import datetime, timedelta

from app.schemas.course_platform_schemas import (
    PlaybackResponse,
    PlaybackData,
    ProgressResponse,
    Progress,
    UpdateProgressRequest,
    ResolutionOption,
    create_error_response,
    APIErrorCode,
)
from app.services.cdn_service import CDNService
from app.services.progress_service import ProgressService
from app.services.enrollment_service import EnrollmentService
from app.dependencies import get_current_user

router = APIRouter(prefix="/videos", tags=["Playback"])


@router.get("/{video_id}/playback", response_model=PlaybackResponse)
async def get_playback_info(
    video_id: str,
    current_user = Depends(get_current_user),
    cdn_service: CDNService = Depends(),
    enrollment_service: EnrollmentService = Depends(),
    progress_service: ProgressService = Depends(),
):
    """
    取得影片播放資訊

    - **WBS 任務**: 5.1.B 影音資源安全 URL 發放
    - **Owner**: Celia

    安全機制:
    1. 驗證用戶已報名課程
    2. 生成帶 Token 的 CDN URL
    3. URL 有效期 4 小時
    """
    # 取得影片資訊
    video = video_service.get_video(video_id)
    if not video:
        raise HTTPException(status_code=404)

    # 驗證報名狀態
    if not enrollment_service.is_enrolled(current_user.id, video.course_id):
        raise HTTPException(status_code=403, detail={
            "success": False,
            "error": {
                "code": APIErrorCode.NOT_ENROLLED.value,
                "message": "請先報名此課程",
            }
        })

    # 生成安全 URL
    expires_at = datetime.utcnow() + timedelta(hours=4)
    token = cdn_service.generate_signed_token(video_id, expires_at)

    base_url = f"https://cdn.example.com/hls/{video_id}"

    # 取得播放進度
    progress = progress_service.get_progress(current_user.id, video_id)

    return PlaybackResponse(
        success=True,
        data=PlaybackData(
            videoId=video_id,
            title=video.title,
            duration=video.duration,
            hlsUrl=f"{base_url}/master.m3u8?token={token}",
            resolutions=[
                ResolutionOption(label="720p", url=f"{base_url}/720p.m3u8?token={token}"),
                ResolutionOption(label="1080p", url=f"{base_url}/1080p.m3u8?token={token}"),
            ],
            expiresAt=expires_at,
            progress=Progress(
                position=progress.position if progress else 0,
                completed=progress.completed if progress else False,
            ),
        ),
    )


@router.put("/{video_id}/progress", response_model=ProgressResponse)
async def update_progress(
    video_id: str,
    request: UpdateProgressRequest,
    current_user = Depends(get_current_user),
    progress_service: ProgressService = Depends(),
):
    """
    更新播放進度

    - **WBS 任務**: 5.2.F 斷點續看功能
    - **Owner**: Celia
    - **建議**: 前端每 10 秒回報一次
    """
    # 計算是否完成 (觀看超過 90%)
    completed = False
    if request.duration and request.duration > 0:
        completed = (request.position / request.duration) >= 0.9

    progress = progress_service.update_progress(
        user_id=current_user.id,
        video_id=video_id,
        position=request.position,
        completed=completed,
    )

    return ProgressResponse(
        success=True,
        data=Progress(
            position=progress.position,
            completed=progress.completed,
        ),
    )
```

---

## 4. Mock Server 設定

Mock Server 讓前端在後端 API 完成前就能開始開發。

### 4.1 使用 Prism (推薦)

```bash
# 安裝 Prism
npm install -g @stoplight/prism-cli

# 啟動 Mock Server
cd D:\sideproject\CONTRACT_TEMPLATES
prism mock course_platform_api_contract.yaml --port 4010

# Mock Server 運行在 http://localhost:4010
```

**前端切換至 Mock Server:**

```env
# .env.development
NEXT_PUBLIC_API_URL=http://localhost:4010/api/v1
```

### 4.2 使用 Docker 運行

```yaml
# docker-compose.mock.yml
version: '3.8'
services:
  mock-api:
    image: stoplight/prism:4
    command: mock -h 0.0.0.0 /api/contract.yaml
    ports:
      - "4010:4010"
    volumes:
      - ./CONTRACT_TEMPLATES:/api:ro
```

```bash
docker-compose -f docker-compose.mock.yml up -d
```

### 4.3 Prism 進階設定

```bash
# 動態回應 (隨機資料)
prism mock course_platform_api_contract.yaml --dynamic

# 驗證請求格式
prism mock course_platform_api_contract.yaml --errors

# 指定回應延遲 (模擬網路延遲)
prism mock course_platform_api_contract.yaml --delay 500
```

### 4.4 使用 MSW (Mock Service Worker)

適合整合測試和前端單元測試：

```bash
npm install msw --save-dev
```

```typescript
// src/mocks/handlers.ts
import { rest } from 'msw';
import type { CourseListResponse } from '@/types/api';

export const handlers = [
  // 課程列表
  rest.get('*/api/v1/courses', (req, res, ctx) => {
    const response: CourseListResponse = {
      success: true,
      data: {
        courses: [
          {
            id: 'crs_mock001',
            title: 'Mock 課程 1',
            description: '這是 Mock 課程',
            thumbnail: null,
            instructorId: 'usr_inst001',
            instructor: {
              id: 'usr_inst001',
              name: 'Mock 講師',
              avatar: null,
            },
            duration: 3600,
            videoCount: 10,
            enrollmentCount: 100,
            status: 'published',
            createdAt: new Date().toISOString(),
          },
        ],
        pagination: {
          page: 1,
          limit: 12,
          total: 1,
          totalPages: 1,
        },
      },
    };
    return res(ctx.json(response));
  }),
];

// src/mocks/browser.ts
import { setupWorker } from 'msw';
import { handlers } from './handlers';

export const worker = setupWorker(...handlers);

// 在開發環境啟用
if (process.env.NODE_ENV === 'development') {
  worker.start();
}
```

---

## 5. 自動化生成型別檔案

### 5.1 使用 openapi-typescript (TypeScript)

```bash
# 安裝
npm install -g openapi-typescript

# 生成 TypeScript 型別
openapi-typescript D:\sideproject\CONTRACT_TEMPLATES\course_platform_api_contract.yaml \
  -o D:\sideproject\CONTRACT_TEMPLATES\generated\api-types.ts
```

### 5.2 使用 datamodel-code-generator (Python)

```bash
# 安裝
pip install datamodel-code-generator

# 生成 Pydantic 模型
datamodel-codegen \
  --input D:\sideproject\CONTRACT_TEMPLATES\course_platform_api_contract.yaml \
  --input-file-type openapi \
  --output D:\sideproject\CONTRACT_TEMPLATES\generated\api_models.py \
  --use-default \
  --use-title-as-name
```

### 5.3 自動化腳本

建立 `scripts/generate-types.sh`:

```bash
#!/bin/bash
# scripts/generate-types.sh
# 從 OpenAPI 契約自動生成前後端型別

set -e

CONTRACT_PATH="D:/sideproject/CONTRACT_TEMPLATES/course_platform_api_contract.yaml"
OUTPUT_DIR="D:/sideproject/CONTRACT_TEMPLATES/generated"

echo "Creating output directory..."
mkdir -p "$OUTPUT_DIR"

echo "Generating TypeScript types..."
npx openapi-typescript "$CONTRACT_PATH" -o "$OUTPUT_DIR/api-types.ts"

echo "Generating Python models..."
datamodel-codegen \
  --input "$CONTRACT_PATH" \
  --input-file-type openapi \
  --output "$OUTPUT_DIR/api_models.py" \
  --use-default

echo "Done! Generated files:"
ls -la "$OUTPUT_DIR"
```

Windows 版本 `scripts/generate-types.ps1`:

```powershell
# scripts/generate-types.ps1
$CONTRACT_PATH = "D:\sideproject\CONTRACT_TEMPLATES\course_platform_api_contract.yaml"
$OUTPUT_DIR = "D:\sideproject\CONTRACT_TEMPLATES\generated"

Write-Host "Creating output directory..."
New-Item -ItemType Directory -Force -Path $OUTPUT_DIR | Out-Null

Write-Host "Generating TypeScript types..."
npx openapi-typescript $CONTRACT_PATH -o "$OUTPUT_DIR\api-types.ts"

Write-Host "Generating Python models..."
datamodel-codegen `
  --input $CONTRACT_PATH `
  --input-file-type openapi `
  --output "$OUTPUT_DIR\api_models.py" `
  --use-default

Write-Host "Done! Generated files:"
Get-ChildItem $OUTPUT_DIR
```

### 5.4 使用 Makefile

```makefile
# Makefile
CONTRACT := CONTRACT_TEMPLATES/course_platform_api_contract.yaml
GEN_DIR := CONTRACT_TEMPLATES/generated

.PHONY: generate-types validate-contract

generate-types:
	@echo "Generating TypeScript types..."
	npx openapi-typescript $(CONTRACT) -o $(GEN_DIR)/api-types.ts
	@echo "Generating Python models..."
	datamodel-codegen --input $(CONTRACT) --input-file-type openapi --output $(GEN_DIR)/api_models.py
	@echo "Done!"

validate-contract:
	@echo "Validating OpenAPI contract..."
	npx @redocly/cli lint $(CONTRACT)

mock-server:
	prism mock $(CONTRACT) --port 4010
```

---

## 6. CI/CD 整合

### 6.1 GitHub Actions 工作流程

```yaml
# .github/workflows/api-contract.yml
name: API Contract Validation

on:
  push:
    paths:
      - 'CONTRACT_TEMPLATES/**'
  pull_request:
    paths:
      - 'CONTRACT_TEMPLATES/**'

jobs:
  validate:
    name: Validate OpenAPI Contract
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm install -g @redocly/cli @stoplight/spectral-cli

      - name: Lint OpenAPI contract
        run: |
          redocly lint CONTRACT_TEMPLATES/course_platform_api_contract.yaml
          spectral lint CONTRACT_TEMPLATES/course_platform_api_contract.yaml

  generate-types:
    name: Generate Type Definitions
    runs-on: ubuntu-latest
    needs: validate
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          npm install -g openapi-typescript
          pip install datamodel-code-generator

      - name: Generate TypeScript types
        run: |
          mkdir -p CONTRACT_TEMPLATES/generated
          openapi-typescript CONTRACT_TEMPLATES/course_platform_api_contract.yaml \
            -o CONTRACT_TEMPLATES/generated/api-types.ts

      - name: Generate Python models
        run: |
          datamodel-codegen \
            --input CONTRACT_TEMPLATES/course_platform_api_contract.yaml \
            --input-file-type openapi \
            --output CONTRACT_TEMPLATES/generated/api_models.py

      - name: Upload generated types
        uses: actions/upload-artifact@v4
        with:
          name: generated-types
          path: CONTRACT_TEMPLATES/generated/

  contract-test:
    name: Contract Testing
    runs-on: ubuntu-latest
    needs: validate
    services:
      mock-api:
        image: stoplight/prism:4
        ports:
          - 4010:4010
        options: >-
          --health-cmd "wget -q -O /dev/null http://localhost:4010"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - uses: actions/checkout@v4

      - name: Copy contract to mock server
        run: docker cp CONTRACT_TEMPLATES/course_platform_api_contract.yaml mock-api:/api/contract.yaml

      - name: Run contract tests
        run: |
          # 測試 API 端點
          curl -f http://localhost:4010/api/v1/courses || exit 1
          curl -f http://localhost:4010/api/v1/courses/crs_test001 || exit 1
          echo "All contract tests passed!"
```

### 6.2 Pre-commit Hook

```yaml
# .pre-commit-config.yaml
repos:
  - repo: local
    hooks:
      - id: validate-openapi
        name: Validate OpenAPI Contract
        entry: npx @redocly/cli lint CONTRACT_TEMPLATES/course_platform_api_contract.yaml
        language: system
        files: 'course_platform_api_contract\.yaml$'
        pass_filenames: false

      - id: generate-types
        name: Generate Type Definitions
        entry: bash scripts/generate-types.sh
        language: system
        files: 'course_platform_api_contract\.yaml$'
        pass_filenames: false
```

安裝 pre-commit:

```bash
pip install pre-commit
pre-commit install
```

### 6.3 契約版本管理

```yaml
# 在 api_contract.yaml 中維護版本
info:
  version: "1.0.0"  # 遵循 Semantic Versioning
  description: |
    ## 變更歷史
    | 版本 | 日期 | 變更者 | 變更內容 |
    |------|------|--------|----------|
    | v1.1.0 | 2025-01-05 | 子科 | 新增課程分類 API |
    | v1.0.0 | 2025-12-29 | 冠瑋 | 初始版本 |
```

### 6.4 自動部署文件

```yaml
# .github/workflows/deploy-docs.yml
name: Deploy API Documentation

on:
  push:
    branches: [main]
    paths:
      - 'CONTRACT_TEMPLATES/**'

jobs:
  deploy-docs:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Generate API Documentation
        run: |
          npx @redocly/cli build-docs CONTRACT_TEMPLATES/course_platform_api_contract.yaml \
            -o docs/api/index.html

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./docs/api
```

---

## 7. 協作流程與規範

### 7.1 開發流程

```
┌────────────────────────────────────────────────────────────────┐
│                    契約驅動開發流程                              │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  第一階段: 契約定義 (Day 1)                                     │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │ 1. 後端 Owner 根據 WBS 需求更新 api_contract.yaml        │  │
│  │ 2. 召開 API Review 會議                                  │  │
│  │ 3. 前端提出修改建議                                       │  │
│  │ 4. 確認後將狀態改為 "Approved"                           │  │
│  │ 5. 執行 generate-types 生成型別檔案                      │  │
│  └─────────────────────────────────────────────────────────┘  │
│                           ↓                                    │
│  第二階段: 平行開發 (Day 2-5)                                   │
│  ┌──────────────────────┐    ┌───────────────────────────┐   │
│  │ 前端團隊              │    │ 後端團隊                  │   │
│  │ • 啟動 Mock Server   │    │ • 使用 schemas.py 開發    │   │
│  │ • 使用 types.ts 開發 │    │ • 實作 API 邏輯           │   │
│  │ • 完成 UI 與串接邏輯  │    │ • 撰寫單元測試            │   │
│  └──────────────────────┘    └───────────────────────────┘   │
│                           ↓                                    │
│  第三階段: 整合測試 (Day 6)                                     │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │ 1. 前端切換至真實 API                                    │  │
│  │ 2. 執行整合測試                                          │  │
│  │ 3. 修復不一致問題                                        │  │
│  │ 4. 契約狀態改為 "Frozen"                                 │  │
│  └─────────────────────────────────────────────────────────┘  │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### 7.2 契約變更規範

#### 允許的變更 (向後相容)

- 新增選填欄位
- 新增新的 API 端點
- 新增新的回應屬性
- 擴展 enum 值

#### 需要協調的變更 (破壞性變更)

- 修改必填欄位
- 刪除現有端點
- 修改回應結構
- 更改 URL 路徑

```yaml
# 破壞性變更需更新主版本號
info:
  version: "2.0.0"  # 從 1.x.x 升級到 2.0.0
```

### 7.3 API Review 檢查清單

```markdown
## API Review Checklist

### 通用檢查
- [ ] 端點命名遵循 RESTful 規範
- [ ] 使用正確的 HTTP 方法 (GET/POST/PUT/DELETE)
- [ ] 回應格式符合 BaseResponse 結構
- [ ] 錯誤碼定義在 APIErrorCode 中

### 安全性檢查
- [ ] 需要認證的端點有設定 security
- [ ] 權限檢查邏輯正確 (student/instructor/admin)
- [ ] 敏感資料不在公開 API 回傳

### 效能檢查
- [ ] 列表 API 有分頁功能
- [ ] 避免 N+1 查詢
- [ ] 回應大小合理

### 文件檢查
- [ ] 每個端點有 summary 和 description
- [ ] 標註 WBS 任務編號
- [ ] 標註 Owner
```

---

## 8. 常見問題 FAQ

### Q1: 契約更新後，如何同步給團隊？

```bash
# 1. 更新 YAML 契約
# 2. 執行生成腳本
powershell scripts/generate-types.ps1

# 3. 提交變更
git add CONTRACT_TEMPLATES/
git commit -m "feat(api): 新增課程分類 API"
git push

# 4. 通知團隊 (Slack/Teams)
```

### Q2: Mock Server 回傳的資料與預期不符？

Prism 預設使用 `example` 欄位的值，確保契約中有定義：

```yaml
responses:
  '200':
    content:
      application/json:
        example:  # 加入這個
          success: true
          data:
            id: "crs_example"
            title: "範例課程"
```

### Q3: 如何測試錯誤回應？

```bash
# Prism 支援 Prefer header 指定回應
curl -H "Prefer: code=404" http://localhost:4010/api/v1/courses/invalid

curl -H "Prefer: code=401" http://localhost:4010/api/v1/auth/me
```

### Q4: TypeScript 型別與實際 API 不一致？

1. 確認是否使用最新的型別檔案
2. 重新執行 `generate-types` 腳本
3. 清除前端快取: `rm -rf .next && npm run dev`

### Q5: 如何在 Postman 中測試？

1. 開啟 Postman
2. File → Import → 選擇 `course_platform_api_contract.yaml`
3. 自動產生所有請求集合
4. 設定環境變數:
   - `baseUrl`: `http://localhost:8000/api/v1`
   - `accessToken`: (登入後取得)

### Q6: 如何產生 API 文件網站？

```bash
# 使用 Redoc
npx @redocly/cli build-docs CONTRACT_TEMPLATES/course_platform_api_contract.yaml -o docs/api.html

# 本地預覽
npx @redocly/cli preview-docs CONTRACT_TEMPLATES/course_platform_api_contract.yaml
```

---

## 附錄

### A. 相關文件

- [OpenAPI 3.0 規範](https://spec.openapis.org/oas/v3.0.3)
- [Pydantic 文件](https://docs.pydantic.dev/)
- [Prism Mock Server](https://docs.stoplight.io/docs/prism)
- [VibeCoding 工作流程模板](../VibeCoding_Workflow_Templates/INDEX.md)

### B. 工具安裝命令

```bash
# 全域工具
npm install -g @stoplight/prism-cli
npm install -g @redocly/cli
npm install -g openapi-typescript

pip install datamodel-code-generator
pip install pre-commit
```

### C. 聯絡資訊

| 角色 | 姓名 | 負責範圍 |
|------|------|----------|
| Tech Lead | 冠瑋 | 契約管理、影片上傳 |
| 後端 | Celia | 認證、播放 |
| 後端 | 子科 | 課程、報名 |
| 前端 | 古古 | UI 開發 |
| 前端 | Jane | UI 開發 |

---

**文件結束**

> 本文件隨專案演進持續更新，最新版本請參考 Git 儲存庫。
